// Copyright (c) 2023 - 2025 Restate Software, Inc., Restate GmbH.
// All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

mod config;

use anyhow::{Context, Result};
use clap_complete::{generate, Shell};
use cling::prelude::*;
use std::io;

use crate::app::CliApp;
use config::ShellConfig;

#[derive(Run, Subcommand, Clone, Debug)]
pub enum Completions {
    /// Generate completions to stdout
    Generate(Generate),
    /// Install completions automatically to shell configuration
    Install(Install),
}

#[derive(Run, Parser, Collect, Clone, Debug)]
#[cling(run = "generate_completions")]
pub struct Generate {
    /// Shell to generate completions for
    #[clap(value_enum)]
    shell: Option<Shell>,
}

async fn generate_completions(opts: &Generate) -> Result<()> {
    let detected_shell = get_or_detect_shell(opts.shell);
    let binary_name = get_binary_name();
    let mut cmd = CliApp::command();

    println!("# Shell completions for {binary_name} ({detected_shell})");
    println!("# Generated by restatectl completions generate");
    println!();

    generate(detected_shell, &mut cmd, &binary_name, &mut io::stdout());
    Ok(())
}

#[derive(Run, Parser, Collect, Clone, Debug)]
#[cling(run = "install_completions")]
pub struct Install {
    /// Shell to install completions for
    #[clap(value_enum)]
    shell: Option<Shell>,
}

async fn install_completions(opts: &Install) -> Result<()> {
    let detected_shell = get_or_detect_shell(opts.shell);
    let binary_name = get_binary_name();

    match detected_shell {
        Shell::PowerShell => {
            eprintln!("PowerShell completions cannot be installed automatically.");
            eprintln!("Please run `{binary_name} completions generate powershell` and follow the instructions in the output.");
            std::process::exit(1);
        }
        Shell::Elvish => {
            eprintln!("Elvish shell is not supported yet.");
            std::process::exit(1);
        }
        _ => {}
    }

    let config = ShellConfig::for_shell(detected_shell)
        .ok_or_else(|| anyhow::anyhow!("Unsupported shell: {:?}", detected_shell))?;

    let home_dir = dirs::home_dir()
        .ok_or_else(|| anyhow::anyhow!("Could not determine home directory"))?;

    let completions_dir = home_dir.join(config.completion_path);
    let file_name = config.file_name(&binary_name, detected_shell);
    let completions_path = completions_dir.join(&file_name);

    // Create the directory if it doesn't exist
    std::fs::create_dir_all(&completions_dir)
        .with_context(|| format!("Failed to create directory: {completions_dir:?}"))?;

    // Generate completions to a string
    let mut buffer = Vec::new();
    let mut cmd = CliApp::command();
    generate(detected_shell, &mut cmd, &binary_name, &mut buffer);

    // Write to file
    std::fs::write(&completions_path, buffer)
        .with_context(|| format!("Failed to write completions to {completions_path:?}"))?;

    println!("{} completions installed to: {}", detected_shell, completions_path.display());
    println!("{}", config.post_install_message);

    Ok(())
}

fn get_or_detect_shell(shell: Option<Shell>) -> Shell {
    shell.unwrap_or_else(|| Shell::from_env().unwrap_or(Shell::Bash))
}

fn get_binary_name() -> String {
    CliApp::command()
        .get_bin_name()
        .unwrap_or("restatectl")
        .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_binary_name() {
        let name = get_binary_name();
        assert_eq!(name, "restatectl");
    }

    #[test]
    fn test_shell_override() {
        let shell = get_or_detect_shell(Some(Shell::Zsh));
        assert_eq!(shell, Shell::Zsh);
    }
}