use crate::utils::GenericError;
use bytes::Bytes;
use bytestring::ByteString;
use opentelemetry_api::trace::SpanContext;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::fmt::Display;
use uuid::Uuid;

/// Identifying a member of a raft group
pub type PeerId = u64;

/// Identifying the leader epoch of a raft group leader
pub type LeaderEpoch = u64;

/// Identifying the partition
pub type PartitionId = u64;

/// The leader epoch of a given partition
pub type PartitionLeaderEpoch = (PartitionId, LeaderEpoch);

pub type EntryIndex = u32;

/// Identifying to which partition a key belongs. This is unlike the [`PartitionId`]
/// which identifies a consecutive range of partition keys.
pub type PartitionKey = u64;

/// Discriminator for invocation instances
pub type InvocationId = Uuid;

/// Id of a single service invocation.
///
/// A service invocation id is composed of a [`ServiceId`] and an [`InvocationId`]
/// that makes the id unique.
#[derive(Eq, Hash, PartialEq, Clone, Debug, Serialize, Deserialize)]
pub struct ServiceInvocationId {
    /// Identifies the invoked service
    pub service_id: ServiceId,
    /// Uniquely identifies this invocation instance
    pub invocation_id: InvocationId,
}

impl Display for ServiceInvocationId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}[{:?}]({})",
            self.service_id.service_name, self.service_id.key, self.invocation_id
        )
    }
}

impl ServiceInvocationId {
    pub fn new(
        service_name: impl Into<ByteString>,
        key: impl Into<Bytes>,
        invocation_id: impl Into<InvocationId>,
    ) -> Self {
        Self {
            service_id: ServiceId {
                service_name: service_name.into(),
                key: key.into(),
            },
            invocation_id: invocation_id.into(),
        }
    }
}

/// Id of a keyed service instance.
///
/// Services are isolated by key. This means that there cannot be two concurrent
/// invocations for the same service instance (service name, key).
#[derive(Eq, Hash, PartialEq, Clone, Debug, Serialize, Deserialize)]
pub struct ServiceId {
    /// Identifies the grpc service
    pub service_name: ByteString,
    /// Identifies the service instance for the given service name
    pub key: Bytes,
}

impl ServiceId {
    pub fn new(service_name: impl Into<ByteString>, key: impl Into<Bytes>) -> Self {
        Self {
            service_name: service_name.into(),
            key: key.into(),
        }
    }
}

/// Representing a service invocation
#[derive(Debug, Clone)]
pub struct ServiceInvocation {
    pub id: ServiceInvocationId,
    pub method_name: ByteString,
    pub argument: Bytes,
    pub response_sink: ServiceInvocationResponseSink,
    pub span_relation: SpanRelation,
}

#[derive(Debug, thiserror::Error)]
pub enum ServiceInvocationFactoryError {
    #[error("service method '{service_name}/{method_name}' is unknown")]
    UnknownServiceMethod {
        service_name: String,
        method_name: String,
    },
    #[error("failed extracting the key from the request payload: {0}")]
    KeyExtraction(GenericError),
}

impl ServiceInvocationFactoryError {
    pub fn unknown_service_method(
        service_name: impl Into<String>,
        method_name: impl Into<String>,
    ) -> Self {
        ServiceInvocationFactoryError::UnknownServiceMethod {
            service_name: service_name.into(),
            method_name: method_name.into(),
        }
    }

    pub fn key_extraction_error(source: impl Into<GenericError>) -> Self {
        ServiceInvocationFactoryError::KeyExtraction(source.into())
    }
}

/// Trait to create a new [`ServiceInvocation`].
///
/// This trait can be used by ingresses and partition processors to
/// abstract the logic to perform key extraction and id generation.
pub trait ServiceInvocationFactory {
    /// Create a new service invocation.
    fn create(
        &self,
        service_name: &str,
        method_name: &str,
        request_payload: Bytes,
        response_sink: ServiceInvocationResponseSink,
        span_relation: SpanRelation,
    ) -> Result<ServiceInvocation, ServiceInvocationFactoryError>;
}

/// Representing a response for a caller
#[derive(Debug, Clone)]
pub struct InvocationResponse {
    pub id: ServiceInvocationId,
    pub entry_index: EntryIndex,
    pub result: ResponseResult,
}

#[derive(Debug, Clone)]
pub enum ResponseResult {
    Success(Bytes),
    Failure(i32, ByteString),
}

#[derive(Debug, PartialEq, Eq, Clone, Hash)]
pub struct IngressId(pub std::net::SocketAddr);

/// Definition of the sink where to send the result of a service invocation.
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ServiceInvocationResponseSink {
    /// The invocation has been generated by a request received at an ingress, and the client is expecting a response back.
    Ingress(IngressId),
    /// The invocation is fire and forget, response can be discarded.
    None,
}

/// Span relation, used to propagate tracing contexts.
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SpanRelation {
    None,
    Parent(SpanContext),
    CausedBy(SpanContext),
}

impl SpanRelation {
    pub fn from_parent(span_context: SpanContext) -> Self {
        SpanRelation::Parent(span_context)
    }

    pub fn from_cause(span_context: SpanContext) -> Self {
        SpanRelation::CausedBy(span_context)
    }

    pub fn to_parent(&self) -> Option<SpanContext> {
        match self {
            SpanRelation::Parent(context) => Some(context.clone()),
            _ => None,
        }
    }

    pub fn to_cause(&self) -> Option<SpanContext> {
        match self {
            SpanRelation::CausedBy(context) => Some(context.clone()),
            _ => None,
        }
    }
}

/// Wrapper that extends a message with its target peer to which the message should be sent.
pub type PeerTarget<Msg> = (PeerId, Msg);

#[derive(Debug, Clone, Copy)]
pub enum AckKind {
    Acknowledge(u64),
    Duplicate(u64),
}
