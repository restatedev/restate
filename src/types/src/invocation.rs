//! This module contains all the core types representing a service invocation.

use crate::errors::UserErrorCode;
use crate::identifiers::{EntryIndex, IngressId, ServiceInvocationId};
use bytes::Bytes;
use bytestring::ByteString;
use opentelemetry_api::trace::{SpanContext, TraceContextExt};
use tracing::{info_span, Span};
use tracing_opentelemetry::OpenTelemetrySpanExt;

/// Struct representing an invocation to a service. This struct is processed by Restate to execute the invocation.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ServiceInvocation {
    pub id: ServiceInvocationId,
    pub method_name: ByteString,
    pub argument: Bytes,
    pub response_sink: Option<ServiceInvocationResponseSink>,
    pub span_context: ServiceInvocationSpanContext,
}

impl ServiceInvocation {
    /// Create a new [`ServiceInvocation`].
    ///
    /// This method returns the [`Span`] associated to the created [`ServiceInvocation`].
    /// It is not required to keep this [`Span`] around for the whole lifecycle of the invocation.
    /// On the contrary, it is encouraged to drop it as soon as possible,
    /// to let the exporter commit this span to jaeger/zipkin to visualize intermediate results of the invocation.
    pub fn new(
        id: ServiceInvocationId,
        method_name: ByteString,
        argument: Bytes,
        response_sink: Option<ServiceInvocationResponseSink>,
        related_span: SpanRelation,
    ) -> (Self, Span) {
        let (span_context, span) =
            ServiceInvocationSpanContext::start(&id, &method_name, related_span);
        (
            Self {
                id,
                method_name,
                argument,
                response_sink,
                span_context,
            },
            span,
        )
    }
}

/// Representing a response for a caller
#[derive(Debug, Clone, PartialEq)]
pub struct InvocationResponse {
    pub id: ServiceInvocationId,
    pub entry_index: EntryIndex,
    pub result: ResponseResult,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ResponseResult {
    Success(Bytes),
    Failure(UserErrorCode, ByteString),
}

/// Definition of the sink where to send the result of a service invocation.
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ServiceInvocationResponseSink {
    /// The invocation has been created by a partition processor and is expecting a response.
    PartitionProcessor {
        caller: ServiceInvocationId,
        entry_index: EntryIndex,
    },
    /// The invocation has been generated by a request received at an ingress, and the client is expecting a response back.
    Ingress(IngressId),
}

/// This struct contains the relevant span information for a [`ServiceInvocation`].
/// It can be used to create related spans, such as child spans,
/// using [`ServiceInvocationSpanContext::as_cause`] or [`ServiceInvocationSpanContext::as_parent`].
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ServiceInvocationSpanContext(SpanContext);

impl ServiceInvocationSpanContext {
    pub fn new(span_context: SpanContext) -> Self {
        ServiceInvocationSpanContext(span_context)
    }

    pub fn empty() -> Self {
        ServiceInvocationSpanContext(SpanContext::empty_context())
    }

    /// See [`ServiceInvocation::new`] for more details.
    pub fn start(
        service_invocation_id: &ServiceInvocationId,
        method_name: &str,
        related_span: SpanRelation,
    ) -> (ServiceInvocationSpanContext, Span) {
        // Create the span
        let span = info_span!(
            "service_invocation",
            rpc.system = "restate",
            rpc.service = %service_invocation_id.service_id.service_name,
            rpc.method = method_name,
            restate.invocation.sid = %service_invocation_id);

        // Attach the related span.
        // Note: As it stands with tracing_opentelemetry 0.18 there seems to be
        // an ordering relationship between using OpenTelemetrySpanExt::context() and
        // OpenTelemetrySpanExt::set_parent().
        // If we invert the order, the spans won't link correctly because they'll have a different Trace ID.
        // This is the reason why this method gets a SpanRelation, rather than letting the caller
        // link the spans.
        // https://github.com/tokio-rs/tracing/issues/2520
        related_span.attach_to_span(&span);

        // Retrieve the OTEL SpanContext we want to propagate
        let span_context = span.context().span().span_context().clone();

        (ServiceInvocationSpanContext(span_context), span)
    }

    pub fn as_cause(&self) -> SpanRelation {
        SpanRelation::CausedBy(self.0.clone())
    }

    pub fn as_parent(&self) -> SpanRelation {
        SpanRelation::Parent(self.0.clone())
    }
}

impl From<ServiceInvocationSpanContext> for SpanContext {
    fn from(value: ServiceInvocationSpanContext) -> Self {
        value.0
    }
}

/// Span relation, used to propagate tracing contexts.
#[derive(Debug, PartialEq, Eq, Clone)]
pub enum SpanRelation {
    None,
    Parent(SpanContext),
    CausedBy(SpanContext),
}

impl SpanRelation {
    /// Attach this [`SpanRelation`] to the given [`Span`]
    pub fn attach_to_span(self, span: &Span) {
        match self {
            SpanRelation::Parent(parent) => {
                span.set_parent(opentelemetry_api::Context::new().with_remote_span_context(parent))
            }
            SpanRelation::CausedBy(cause) => span.add_link(cause),
            _ => {}
        };
    }
}
